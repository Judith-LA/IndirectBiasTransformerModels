<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script type = "text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
		<script type="text/javascript" src="../legend.js"></script>
		<link href="https://fonts.googleapis.com/css2?family=Assistant:wght@200&family=Source+Sans+Pro:wght@300&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="style.css"></link>
		<title>Indirect Bias Exploration - Visualization 2</title>
	</head>
	<body>
		<div id='introductionDiv'>
			<h1> Indirect Bias Exploration - Visualization 2</h1>
			<h2> Introduction </h2>
				<p> 
					The purpose of this visualization is to explore the potential biases learned by NLP transformer models, machine learning models which can be used to deal with human language. 
				</p>

				<p> 
					You will be able to choose a target category attribute (e.g. sport) and see the correlations made by the chosen model with different feature category attributes (e.g. beverage or trait). 
					It is also possible to investigate the correlations between the target and feature attributes and some <em>sensitive</em> attributes (such as gender or religion), to check whether the target and feature elements could be linked by some indirect correlations with these sensitive features. The correlation scores for different models are available. 
				</p>

				<p>	
					The visualization is composed of a scatterplot, where each dot represents an element from the chosen target category. The position of the dots is defined by the feature category. High-dimensional vectors are derived from the correlation scores between the target and feature elements, which are mapped to a 2-dimensional space using a dimensionality reduction. Different dimensionality reductions are available. 
					It is possible to zoom in on the scatterplot to get better insights.
					A color scale can be applied to explore whether it exists a correlation between the target elements and a selected feature or <em>sensitive</em>  element, and how strong this correlation is. 
					The correlations are generated using names as a bridge, which are linked to the target and feature elements. It is possible to explore these links by clicking on the dots of the scatterplot.
				</p>

			<div>
				<br/>
				<button onclick="displayVisulization()"> Go to Visualization </button>
			</div>
		</div>

		<div id="visualizationDiv" hidden>
			<h1> Indirect Bias Exploration - Visualization 2</h1>

			<div>
				<div id='divModel' style='text-align: center; height: 50%; width:100%;'></div>
				<div id='divSelection' style='text-align: center; height: 50%; width:50%; float: left;'></div>
				<div id='divColorScale' style='text-align: center; width:50%; float: right;'></div>
			</div>
			<div>
				<div id='scatterDetails' style='text-align: center; width:50%; float: right;'>
					<div id='slider' class='slider'></div>
					<div>
						<div id='explanationsNull' style="height: 130px;"></div>
						<div id='explanations' style="text-align: left; height: 130px; overflow: auto;" hidden>
							<p> 
								The purpose of this visualization is to explore the potential biases learned by NLP transformer models, machine learning models which can be used to deal with human language. 
							</p>

							<p> 
								You will be able to choose a target category attribute (e.g. sport) and see the correlations made by the chosen model with different feature category attributes (e.g. beverage or trait). 
								It is also possible to investigate the correlations between the target and feature attributes and some <em>sensitive</em> attributes (such as gender or religion), to check whether the target and feature elements could be linked by some indirect correlations with these sensitive features. The correlation scores for different models are available. 
							</p>

							<p>	
								The visualization is composed of a scatterplot, where each dot represents an element from the chosen target category. The position of the dots is defined by the feature category. High-dimensional vectors are derived from the correlation scores between the target and feature elements, which are mapped to a 2-dimensional space using a dimensionality reduction. Different dimensionality reductions are available. 
								It is possible to zoom in on the scatterplot to get better insights.
								A color scale can be applied to explore whether it exists a correlation between the target elements and a selected feature or <em>sensitive</em>  element, and how strong this correlation is. 
								The correlations are generated using names as a bridge, which are linked to the target and feature elements. It is possible to explore these links by clicking on the dots of the scatterplot.
							</p>
						</div>

						<div>
							<br/>
							<button id='explanationsButton' onclick="showExplanations()"> Show introduction text </button>
						</div>
					</div>
				</div>
				<div style='text-align: center; width:50%; float: left;'>
					<div id='divScatterPlot' style='text-align: center; width: 95%;'></div>
				</div>
			</div>
		</div>

		<script type="text/javascript">
			var models = ['bert-base', 'bert-large', 'xl-base', 'xl-large']; // Available models
			var  dimReductions = [{'name': 't-SNE', 'value': 'tsne'},
								  {'name': 'UMAP', 'value': 'umap'},
								  {'name': 'ISOMAP', 'value': 'isomap'}] // Available dimensionality reduction functions
			var target_attributes = ['beverage', 'country', 'occupation', 'sport']; // Available targets
			var sensitive_attributes = ['age', 'gender', 'race', 'religion', 'sexual_orientation', 'yob']; // Available sensitive features

			// Target feature dropdown menu options
			var targetOptions = [{'name': 'Beverage', 'value': 'beverage'}, 
								 {'name': 'Country', 'value': 'country'}, 
								 {'name': 'Occupation', 'value': 'occupation'},
								 {'name': 'Sport', 'value': 'sport'}]
			// Non-sensitive feature dropdown menu options
			var featureOptions = [{'name': 'Beverage', 'value': 'beverage'},
							  	  {'name': 'Country', 'value': 'country'}, 
							  	  {'name': 'Occupation', 'value': 'occupation'},
							  	  {'name': 'Sport', 'value': 'sport'},
							  	  {'name': 'Mental and Physical Traits', 'value': 'trait'}]
			// Sensitive feature dropdown menu options
			var sensitiveOptions = [{'name': 'Age', 'value': 'age'},
									{'name': 'Gender', 'value': 'gender'},
									{'name': 'Race', 'value': 'race'},
									{'name': 'Religion', 'value': 'religion'},
									{'name': 'Sexual Orientation', 'value': 'sexual_orientation'},
									{'name': 'Year of Birth', 'value': 'yob'}]

			// Color scale initialization
			var colorScaleMin = -1, colorScaleMax = 1;
			var colorScale = d3.scaleSequential()
								.domain([colorScaleMin,colorScaleMax])
								.interpolator(d3.interpolatePuOr);
			var colorScaleLegend = {0: 'no correlation'};
			colorScaleLegend[colorScaleMin] = 'strongly negative', colorScaleLegend[colorScaleMax] = 'strongly positive';

			var selectedModel, selectedDimReduction;
			var selectedTarget, selectedFeature, selectedColorScaleFeature, selectedColorScale;

			var delay = 200; // Delay between loading the data and initialize the interface
			var explanationsShown = false; // Boolean defining whether the explanations are displayed

			function loadFilesInit(){ /* Creation of dictionaries which will contain the correlation scores, 
										 correlation scores for indirect scatterplots, and similarity scores 
										 for all the models */
				target_attributes.forEach(function(t1){
					target_attributes.forEach(function(t2){
						if (t1 != t2){
							this[t1 + '_' + t2 + '_corr'] = {};
							this[t1 + '_' + t2 + '_indirect'] = {};
							this[t1 + '_' + t2 + '_scatter'] = {};
							var d_corr = eval(t1 + '_' + t2 + '_corr');
							var d_indirect = eval(t1 + '_' + t2 + '_indirect');
							var d_scatter = eval(t1 + '_' + t2 + '_scatter');
							models.forEach(function(m){;
								d_corr[m] = null;
								d_indirect[m] = null;
								d_scatter[m] = null;
							});
						}
					});

					this[t1 + '_trait' + '_corr'] = {};
					this[t1 + '_trait' + '_indirect'] = {};
					this[t1 + '_trait' + '_scatter'] = {};
					var d_corr = eval(t1 + '_trait' + '_corr');
					var d_indirect = eval(t1 + '_trait'+ '_indirect');
					var d_scatter = eval(t1 + '_trait' + '_scatter');
					models.forEach(function(m){;
						d_corr[m] = null;
						d_indirect[m] = null;
						d_scatter[m] = null;
					});

					sensitive_attributes.forEach(function(s){
						this[t1 + '_' + s + '_corr'] = {};
						this[t1 + '_' + s + '_indirect'] = {};
						this[t1 + '_' + s + '_scatter'] = {};
						var d_corr = eval(t1 + '_' + s + '_corr');
						var d_indirect = eval(t1 + '_' + s + '_indirect');
						var d_scatter = eval(t1 + '_' + s + '_scatter');
						models.forEach(function(m){
							d_corr[m] = null;
							d_indirect[m] = null;
							d_scatter[m] = null;
						});
					});
				});
			};

			function loadFiles(){ // Load the dictionaries
				models.forEach(function(m){
					target_attributes.forEach(function(t1){
						target_attributes.forEach(function(t2){
							if (t1 != t2){
								// Load correlation scores between all the targets and non-sensivitive attributes (except traits)
								var d_corr = eval(t1 + '_' + t2 + '_corr');
								d3.csv("../data/" + m + "/" + t1 + "_" + t2 + "_correlation.csv").then(function(data){
									d_corr[m] = data;
								});
								// Load indirect scatterplots data between all the targets and non-sensivitive attributes (except traits)
								var d_indirect = eval(t1 + '_' + t2 + '_indirect');
								d3.csv("../data/" + m + "/" + t1 + "_" + t2 + "_indirect.csv").then(function(data){
									d_indirect[m] = data;
								});
								// Load main scatterplot data between all the targets and non-sensivitive attributes (except traits)
								var d_scatter = eval(t1 + '_' + t2 + '_scatter');
								d3.csv("../data/" + m + "/" + t1 + "_" + t2 + "_scatter.csv").then(function(data){
									d_scatter[m] = data;
								});
							}
						});

						// Load correlation scores between all the targets and traits
						var d_corr = eval(t1 + '_trait_corr');
						d3.csv("../data/" + m + "/" + t1 + "_trait" + "_correlation.csv").then(function(data){
							d_corr[m] = data;
						});
						// Load indirect scatterplots data between all the targets and traits
						var d_indirect = eval(t1 + '_trait_indirect');
						d3.csv("../data/" + m + "/" + t1 + "_trait" + "_indirect.csv").then(function(data){
							d_indirect[m] = data;
						});
						// Load indirect scatterplots data between all the targets and traits
						var d_scatter = eval(t1 + '_trait_scatter');
						d3.csv("../data/" + m + "/" + t1 + "_trait" + "_scatter.csv").then(function(data){
							d_scatter[m] = data;
						});

						sensitive_attributes.forEach(function(s){
							// Load correlation scores between all the targets and the sensivitive attributes
							var d_corr = eval(t1 + '_' + s + '_corr');
							d3.csv("../data/" + m + "/" + t1 + "_" + s + "_correlation.csv").then(function(data){
								d_corr[m] = data;
							});
							// Load indirect scatterplots data between all the targets and the sensivitive attributes
							var d_indirect = eval(t1 + '_' + s + '_indirect');
							d3.csv("../data/" + m + "/" + t1 + "_" + s + "_indirect.csv").then(function(data){
								d_indirect[m] = data;
							});
							// Load indirect scatterplots data between all the targets and the sensivitive attributes
							var d_scatter = eval(t1 + '_' + s + '_scatter');
							d3.csv("../data/" + m + "/" + t1 + "_" + s + "_scatter.csv").then(function(data){
								d_scatter[m] = data;
							});
						});
					});

				});
			};


			function setUpVisualization(){ // Initialisation of the Control Panel
				d3.select('#divModel').text('Choose the model and dimensionality reduction to use');
				d3.select('#divModel').append('br');

				// Model dropdown menu
				var modelSelect = d3.select('#divModel')
									.append('select')
									.attr('id', 'modelSelect')
									.attr('name', 'modelSelect');
				modelSelect.append('option')
						   .text('-')
						   .attr('value', ' ')
						   .attr('id', 'nullModel');
				modelSelect.selectAll('modelOptions')
						   .data(models)
						   .enter()
						   .append('option')
						   .text(function (d) { return d; })
						   .attr('value', function (d) { return d; })
						   .attr('id', function (d) { return d; });
				modelSelect.on('change', selectModel);

				// Dimensionality reduction dropdown menu
				var dimReductionSelect = d3.select('#divModel')
										   .append('select')
										   .attr('id', 'dimReductionSelect')
										   .attr('name', 'dimReductionSelect');
				dimReductionSelect.append('option')
						   		  .text('-')
						   		  .attr('value', ' ')
						   		  .attr('id', 'nullDimReduction');
				dimReductionSelect.selectAll('modelOptions')
								  .data(dimReductions)
								  .enter()
								  .append('option')
								  .text(function (d) { return d.name; })
								  .attr('value', function (d) { return d.value; })
								  .attr('id', function (d) { return d.value; });
				dimReductionSelect.on('change', selectDimReduction);


				d3.select('#divSelection').text('Choose the attributes to compare');
				d3.select('#divSelection').append('br');

				// Target dropdown menu
				var targetSelect = d3.select('#divSelection')
									 .append('select')
									 .attr('id', 'targetAttr')
									 .attr('name', 'targetAttr');
				targetSelect.append('option')
							.text('-')
							.attr('value', ' ')
							.attr('id', 'nullTarget');
				targetSelect.selectAll('targetOptions')
							.data(targetOptions)
							.enter()
							.append('option')
							.text(function (d) { return d.name; })
							.attr('value', function (d) { return d.value; })
							.attr('id', function (d) { return d.value+'Target'; });
				targetSelect.on('change', selectTarget);
				targetSelect.on('mouseover', function(){ 
												d3.select('#targetSelectLabel').attr('hidden', null); 
												d3.select('#nullLabel').attr('hidden', true); 
											});
				targetSelect.on('mouseout', function(){ 
												d3.select('#targetSelectLabel').attr('hidden', true); 
												d3.select('#nullLabel').attr('hidden', null); 
											});

				// Non-sensitive feature dropdown menu
				var featureSelect = d3.select('#divSelection')
								  	  .append('select')
								  	  .attr('id', 'featureAttr')
									  .attr('name', 'featureAttr');
				featureSelect.append('option')
							 .text('-')
							 .attr('value', ' ')
							 .attr('id', 'nullFeature');
				featureSelect.selectAll('featureOptions')
							 .data(featureOptions)
							 .enter()
							 .append('option')
							 .text(function (d) { return d.name; })
							 .attr('value', function (d) { return d.value; })
							 .attr('id', function (d) { return d.value+'Feature'; });
				featureSelect.on('change', selectFeature);
				featureSelect.on('mouseover', function(){ 
												d3.select('#featureSelectLabel').attr('hidden', null); 
												d3.select('#nullLabel').attr('hidden', true); 
											});
				featureSelect.on('mouseout', function(){ 
												d3.select('#featureSelectLabel').attr('hidden', true); 
												d3.select('#nullLabel').attr('hidden', null); 
											});

				// Sensitive feature dropdown menu
				var sensitiveAttrSelect = d3.select('#divSelection')
											.append('select')
											.attr('id', 'sensitiveAttr')
											.attr('name', 'sensitiveAttr');
				sensitiveAttrSelect.append('option')
								   .text('-')
								   .attr('value', ' ')
								   .attr('id', 'nullSensitiveAttr');
				sensitiveAttrSelect.selectAll('sensitiveAttr')
								   .data(sensitiveOptions)
								   .enter()
								   .append('option')
								   .text(function (d) { return d.name; })
								   .attr('value', function (d) { return d.value; })
								   .attr('id', function (d) { return d.value+'SensitiveAttr'; });
				sensitiveAttrSelect.on('change', selectSensitiveAttr);
				sensitiveAttrSelect.on('mouseover', function(){ 
													d3.select('#sensitiveSelectLabel').attr('hidden', null); 
													d3.select('#nullLabel').attr('hidden', true); 
												});
				sensitiveAttrSelect.on('mouseout', function(){ 
													d3.select('#sensitiveSelectLabel').attr('hidden', true); 
													d3.select('#nullLabel').attr('hidden', null); 
												});

				d3.select('#divSelection').append('br');

				// Attributes dropdown menus legend
				d3.select('#divSelection')
				  .append('Label')
				  .attr('id', 'nullLabel')
				  .style('color', '#E8E8E8')
				  .text('---')
				  .style('font-size', '80%');
				d3.select('#divSelection')
				  .append('Label')
				  .attr('id', 'targetSelectLabel')
				  .attr('for', 'targetAttr')
				  .attr('hidden', true)
				  .text('Target attribute (elements shown)')
				  .style('font-size', '80%');
				d3.select('#divSelection')
				  .append('Label')
				  .attr('id', 'featureSelectLabel')
				  .attr('for', 'featureAttr')
				  .attr('hidden', true)
				  .text('Feature attribute (defining high-dimensional space)')
				  .style('font-size', '80%');
				d3.select('#divSelection')
	   			  .append('Label')
	   			  .attr('id', 'sensitiveSelectLabel')
	   			  .attr('for', 'sensitiveAttr')
	   			  .attr('hidden', true)
	   			  .text('Sensitive attribute (defining high-dimensional space)')
				  .style('font-size', '80%');

				d3.select('#divSelection').attr('hidden', true);

				// Color scale dropdown menus
				d3.select('#divColorScale').text('Choose the feature to scale the colors');
				d3.select('#divColorScale').append('br');
				var colorScaleFeatureSelect = d3.select('#divColorScale')
										 		.append('select')
										 		.attr('id', 'colorScaleFeature')
									 	 		.attr('name', 'colorScaleFeature');
				var colorScaleSelect = d3.select('#divColorScale')
										 .append('select')
										 .attr('id', 'colorScale')
									 	 .attr('name', 'colorScale');
				d3.select('#divColorScale').attr('hidden', true);
			};

			function selectModel(){ // Model selection
				var modelSelect = d3.select('#modelSelect').node();
				var featureSelect = d3.select('#featureAttr');
				var sensitiveAttrSelect = d3.select('#sensitiveAttr');
				var colorScaleFeatureSelect = d3.select('#colorScaleFeature');
				var colorScaleSelect = d3.select('#colorScale');
				selectedModel = modelSelect.options[modelSelect.selectedIndex].value;

				d3.select('#nullModel').attr('disabled', true); // Disable null model option
				// If dimensionality reduction already selected, show attributes selection dropdown menus
				if (selectedDimReduction){ d3.select('#divSelection').attr('hidden', null); } 

				if (selectedTarget && selectedFeature){ // If target and feature already selected, display main scatterplot
					// Get previous selected target
					var clickedCircle = d3.selectAll('circle').filter('.clicked');
					if (!clickedCircle.empty()){ var clickedCircleId = clickedCircle.attr('id'); };

					createMainScatterPlot(selectedTarget, selectedFeature); // Create main scatterplot
					
					// Get previous color scale feature, if any, for consistent color scaling
					var previousSelectedColorScaleFeature, previousSelectedColorScaleIndex; 
					if (selectedColorScaleFeature){
						previousSelectedColorScaleFeature = selectedColorScaleFeature;
						previousSelectedColorScaleAttribute = selectedColorScale+'ColorScale';
					}

					// Reset color scale menus
					colorScaleFeatureSelect.selectAll('option').remove();
					colorScaleSelect.selectAll('option').remove();
					selectedColorFeatureScale = null, selectedColorScale = null;

					d3.select('#divColorScale').attr('hidden', null); // Show color scale menus
					// Add options to color scale feature menu
					colorScaleFeatureSelect.append('option')
											.text('-')
								    		.attr('value', ' ')
											.attr('id', 'nullColorScale');
					if (featureOptions.map(x => x.value).includes(selectedFeature)){
						var colorScaleFeatureOptions = [featureOptions[featureSelect.node().selectedIndex - 1]].concat(sensitiveOptions);
					} else {
						var colorScaleFeatureOptions = [sensitiveOptions[sensitiveAttrSelect.node().selectedIndex - 1]];
					}
					colorScaleFeatureSelect.selectAll('colorScaleFeatureOptions')
							 			   .data(colorScaleFeatureOptions)
							 			   .enter().append('option')
							 			   .text(function (d) { return d.name; })
							 			   .attr('value', function (d) { return d.value; })
							 			   .attr('id', function (d) { return d.value+'ColorScaleFeature'; });
					colorScaleFeatureSelect.on('change', selectColorScaleFeature);

					// If previous color scaling exists, apply this color scaling
					if (previousSelectedColorScaleFeature){
						colorScaleFeatureSelect.node().selectedIndex = Array.from(colorScaleFeatureSelect.node().options
																		).map(x => x.id).indexOf(previousSelectedColorScaleFeature+'ColorScaleFeature');
						selectColorScaleFeature();

						var colorScaleSelectOptions = Array.from(colorScaleSelect.node().options).map(x => x.id);
						if (colorScaleSelectOptions.includes(previousSelectedColorScaleAttribute)){
							colorScaleSelect.node().selectedIndex = colorScaleSelectOptions.indexOf(previousSelectedColorScaleAttribute);
						} else {
							colorScaleSelect.node().selectedIndex = 0;
						}
						selectColorScale();
					}

					// Show indirect scatterplots for selected target
					if (clickedCircleId){ 
   						d3.select('#'+clickedCircleId).classed('clicked', true);
   						d3.select('#'+clickedCircleId).style('fill', 'red');
   						d3.select('#'+clickedCircleId).attr('stroke', 'black');
   						showDetails(clickedCircleId);
					};
				}
			};

			function selectDimReduction(){ // Dimensionality reduction selection 
				var dimReductionSelect = d3.select('#dimReductionSelect').node();
				selectedDimReduction = dimReductionSelect.options[dimReductionSelect.selectedIndex].value;

				d3.select('#nullDimReduction').attr('disabled', true); // Disable null dimensionality reduction option
				// If model already selected, show attributes selection dropdown menus
				if (selectedModel){ d3.select('#divSelection').attr('hidden', null); }

				if (selectedTarget && selectedFeature){ // If target and feature already selected, display main scatterplot
					// Get previous selected target
					var clickedCircle = d3.selectAll('circle').filter('.clicked');
					if (!clickedCircle.empty()){ var clickedCircleId = clickedCircle.attr('id'); };

					createMainScatterPlot(selectedTarget, selectedFeature); // Create main scatterplot
					selectColorScale(); // Apply color scaling
				}
			};

			function selectTarget(){ // Target selection
				d3.select('#divScatterPlot').selectAll('*').remove();
				d3.select('#slider').selectAll('*').remove();

				var targetSelect = d3.select('#targetAttr').node();
				var featureSelect = d3.select('#featureAttr');
				var sensitiveAttrSelect = d3.select('#sensitiveAttr');
				var colorScaleFeatureSelect = d3.select('#colorScaleFeature');
				var colorScaleSelect = d3.select('#colorScale');
				selectedTarget = targetSelect.options[targetSelect.selectedIndex].value;
				
				d3.select('#nullTarget').attr('disabled', true); // Disable null target option
				featureSelect.selectAll('option').attr('disabled', null); // Enable all non-sensitive feature options
				d3.select('#nullFeature').attr('disabled', true); // Disable null non-sensitive feature option
				d3.select('#' + selectedTarget + 'Feature').attr('disabled', true); // Disable selected target option in non-sensitive feature menu
				d3.select('#nullSensitiveAttr').attr('disabled', true); // Disable null sensitive feature option

				if (selectedFeature) { // If feature selected
					createMainScatterPlot(selectedTarget, selectedFeature); // Create main scatterplot

					// Get previous color scale feature, if any, for consistent color scaling
					var previousSelectedColorScaleFeature, previousSelectedColorScaleIndex; 
					if (selectedColorScaleFeature){
						previousSelectedColorScaleFeature = selectedColorScaleFeature;
						previousSelectedColorScaleIndex = Array.from(colorScaleSelect.node().options
																	).map(x => x.id).indexOf(selectedColorScale+'ColorScale');
					}

					// Reset color scale menus
					colorScaleFeatureSelect.selectAll('option').remove();
					colorScaleSelect.selectAll('option').remove();
					selectedColorFeatureScale = null, selectedColorScale = null;

					d3.select('#divColorScale').attr('hidden', null); // Show color scale menus
					// Add options to color scale feature menu
					colorScaleFeatureSelect.append('option')
											.text('-')
								    		.attr('value', ' ')
											.attr('id', 'nullColorScale');
					if (featureOptions.map(x => x.value).includes(selectedFeature)){
						var colorScaleFeatureOptions = [featureOptions[featureSelect.node().selectedIndex - 1]].concat(sensitiveOptions);
					} else {
						var colorScaleFeatureOptions = [sensitiveOptions[sensitiveAttrSelect.node().selectedIndex - 1]];
					}
					colorScaleFeatureSelect.selectAll('colorScaleFeatureOptions')
							 			   .data(colorScaleFeatureOptions)
							 			   .enter().append('option')
							 			   .text(function (d) { return d.name; })
							 			   .attr('value', function (d) { return d.value; })
							 			   .attr('id', function (d) { return d.value+'ColorScaleFeature'; });
					colorScaleFeatureSelect.on('change', selectColorScaleFeature);

					// If previous color scaling exists, apply this color scaling
					if (previousSelectedColorScaleFeature){
						colorScaleFeatureSelect.node().selectedIndex = Array.from(colorScaleFeatureSelect.node().options
																		).map(x => x.id).indexOf(previousSelectedColorScaleFeature+'ColorScaleFeature');
						selectColorScaleFeature();
						colorScaleSelect.node().selectedIndex = previousSelectedColorScaleIndex;
						selectColorScale();
					}
				};
			};

			function selectFeature(){ // Non-sensitive feature selection
				d3.select('#divScatterPlot').selectAll('*').remove();
				d3.select('#slider').selectAll('*').remove();
				
				var targetSelect = d3.select('#targetAttr');
				var featureSelect = d3.select('#featureAttr').node();
				var sensitiveAttrSelect = d3.select('#sensitiveAttr');
				var colorScaleFeatureSelect = d3.select('#colorScaleFeature');
				var colorScaleSelect = d3.select('#colorScale');
				selectedFeature = featureSelect.options[featureSelect.selectedIndex].value;

				targetSelect.selectAll('option').attr('disabled', null); // Enable all target options
				d3.select('#nullTarget').attr('disabled', true); // Disable null target option
				d3.select('#nullFeature').attr('disabled', true); // Disable null non-sensitive feature option
				d3.select('#' + selectedFeature + 'Target').attr('disabled', true); // Disable selected non-sensitive feature option in target menu
				sensitiveAttrSelect.selectAll('option').attr('disabled', null); // Enable all sensitive feature options
				sensitiveAttrSelect.node().selectedIndex = 0; // Set selected sensitive feature to null sensitive feature
				d3.select('#nullSensitiveAttr').attr('disabled', true); // Disable null sensitive feature option

				if (selectedTarget) { // If target selected
					createMainScatterPlot(selectedTarget, selectedFeature); // Create main scatterplot
					
					// Get previous color scale feature on sensitive attribute, if any, for consistent color scaling
					var previousSelectedColorScaleFeature, previousSelectedColorScaleIndex;
					if (selectedColorScaleFeature && 
						sensitiveOptions.map(x => x.value).includes(selectedColorScaleFeature)){
						previousSelectedColorScaleFeature = selectedColorScaleFeature;
						previousSelectedColorScaleIndex = Array.from(colorScaleSelect.node().options
																	).map(x => x.id).indexOf(selectedColorScale+'ColorScale');
					}

					// Reset color scale menus
					colorScaleFeatureSelect.selectAll('option').remove();
					colorScaleSelect.selectAll('option').remove();
					selectedColorFeatureScale = null, selectedColorScale = null;

					
					d3.select('#divColorScale').attr('hidden', null); // Show color scale menus
					// Add options to color scale feature menu
					colorScaleFeatureSelect.append('option')
											.text('-')
								    		.attr('value', ' ')
											.attr('id', 'nullColorScale');
					var colorScaleFeatureOptions = [featureOptions[featureSelect.selectedIndex - 1]].concat(sensitiveOptions);
					colorScaleFeatureSelect.selectAll('colorScaleFeatureOptions')
							 			   .data(colorScaleFeatureOptions)
							 			   .enter().append('option')
							 			   .text(function (d) { return d.name; })
							 			   .attr('value', function (d) { return d.value; })
							 			   .attr('id', function (d) { return d.value+'ColorScaleFeature'; });
					colorScaleFeatureSelect.on('change', selectColorScaleFeature);

					// If previous color scaling exists, apply this color scaling
					if (previousSelectedColorScaleFeature){
						colorScaleFeatureSelect.node().selectedIndex = Array.from(colorScaleFeatureSelect.node().options
																		).map(x => x.id).indexOf(previousSelectedColorScaleFeature+'ColorScaleFeature');
						selectColorScaleFeature();
						colorScaleSelect.node().selectedIndex = previousSelectedColorScaleIndex;
						selectColorScale();
					}
				};
			};

			function selectSensitiveAttr(){ // Sensitive feature selection
				d3.select('#divScatterPlot').selectAll('*').remove();
				d3.select('#slider').selectAll('*').remove(); 
				
				var targetSelect = d3.select('#targetAttr');
				var featureSelect = d3.select('#featureAttr');
				var sensitiveAttrSelect = d3.select('#sensitiveAttr').node();
				var colorScaleFeatureSelect = d3.select('#colorScaleFeature');
				var colorScaleSelect = d3.select('#colorScale');
				selectedFeature = sensitiveAttrSelect.options[sensitiveAttrSelect.selectedIndex].value;

				targetSelect.selectAll('option').attr('disabled', null); // Enable all target options
				d3.select('#nullTarget').attr('disabled', true); // Disable null target option
				featureSelect.selectAll('option').attr('disabled', null); // Enable all non-sensitive feature options
				featureSelect.node().selectedIndex = 0; // Set selected non-sensitive feature to null sensitive feature
				d3.select('#nullFeature').attr('disabled', true); // Disable null non-sensitive feature option
				d3.select('#' + selectedTarget + 'Feature').attr('disabled', true); // Disable selected target option in non-sensitive feature menu
				d3.select('#nullSensitiveAttr').attr('disabled', true); // Disable null sensitive feature option

				if (selectedTarget) { // If target selected
					createMainScatterPlot(selectedTarget, selectedFeature); // Create main scatterplot
					
					// Get previous color scale feature, if equals to selected sensitive feature, for consistent color scaling
					var previousSelectedColorScaleIndex;
					if (selectedColorScaleFeature && (selectedFeature == selectedColorScaleFeature)){
						previousSelectedColorScaleIndex = Array.from(colorScaleSelect.node().options
																		).map(x => x.id).indexOf(selectedColorScale+'ColorScale');
					}

					// Reset color scale menus
					colorScaleFeatureSelect.selectAll('option').remove();
					colorScaleSelect.selectAll('option').remove();
					selectedColorFeatureScale = null, selectedColorScale = null;

					d3.select('#divColorScale').attr('hidden', null); // Show color scale menus
					// Add options to color scale feature menu
					colorScaleFeatureSelect.append('option')
											.text('-')
								    		.attr('value', ' ')
											.attr('id', 'nullColorScale');
					var colorScaleFeatureOptions = [sensitiveOptions[sensitiveAttrSelect.selectedIndex - 1]];
					colorScaleFeatureSelect.selectAll('colorScaleFeatureOptions')
							 			   .data(colorScaleFeatureOptions)
							 			   .enter().append('option')
							 			   .text(function (d) { return d.name; })
							 			   .attr('value', function (d) { return d.value; })
							 			   .attr('id', function (d) { return d.value+'ColorScaleFeature'; });
					colorScaleFeatureSelect.on('change', selectColorScaleFeature);

					// If previous color scaling exists, apply this color scaling
					if (previousSelectedColorScaleIndex){
						colorScaleFeatureSelect.node().selectedIndex = 1;
						selectColorScaleFeature();
						colorScaleSelect.node().selectedIndex = previousSelectedColorScaleIndex;
						selectColorScale();
					}
				};
			};


			function createMainScatterPlot(target, feature){ // Create main scatterplot
				// Define size and margins of the scatter plot
				var margin = {top: 20, right: 20, bottom: 20, left: 20},
					width = 400 - margin.left - margin.right,
					height = 400 - margin.top - margin.bottom;

				var data = eval(target + '_' + feature + '_scatter')[selectedModel]; // Get data

				// Remove previous scatterplot if any
				d3.select('#divScatterPlot').selectAll('*').remove();
				d3.select('#divScatterPlot').append('br');

				// Create SVG which will contain the scatterplot
				var svgInit = d3.select('#divScatterPlot')
								.append('svg')
								.attr('id', 'svg_'+target+'_'+feature)
								.attr('width', width)
								.attr('height', height)
								.attr('preserveAspectRatio', 'xMinYMin meet')
								.attr('viewBox', '0 0 ' + (width + margin.left + margin.right) + ' ' + (height + margin.top + margin.bottom))

				// Add background to SVG
				svgInit.append('rect')
					   .attr('width', '100%')
					   .attr('height', '100%')
					   .attr('stroke', 'black')
					   .attr('fill', 'white');
				var svg = svgInit.append('g')
								 .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

				// Define axes and add them to SVG
				var min_x = d3.min(data, function(d){ return parseFloat(d[feature+'_'+selectedDimReduction+'_x']); }) - .1,
					max_x = d3.max(data, function(d){ return parseFloat(d[feature+'_'+selectedDimReduction+'_x']); }) + .1,
					min_y = d3.min(data, function(d){ return parseFloat(d[feature+'_'+selectedDimReduction+'_y']); }) - .1,
					max_y = d3.max(data, function(d){ return parseFloat(d[feature+'_'+selectedDimReduction+'_y']); }) + .1;
				var x = d3.scaleLinear()
						  .domain([min_x,max_x])
						  .range([0, width]);
				var y = d3.scaleLinear()
						  .domain([min_y,max_y])
						  .range([height, 0]);

				// Add legend tooltip for dots
				var tooltip = d3.select('#divScatterPlot')
								.append('div')
								.attr('class', 'tooltip2')
								.style('opacity', 0);

				// Add zooming feature to SVG
				var brush = d3.brush()
							  .extent([[0,0], [width, height]])
							  .on("end", function(event, d){
							  				extent = event.selection;
							  				if(!extent){
												if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // Add delay to zooming
												x.domain([min_x,max_x]);
												y.domain([min_y,max_y]);
										    } else {
										    	x.domain([extent[0][0], extent[1][0]].map(x.invert, x));
										    	y.domain([extent[1][1], extent[0][1]].map(y.invert, y));
										    	svg.select(".brush").call(brush.move, null);
										    }
										    svg.selectAll("circle").transition().duration(1000)
										       .attr("cx", function(d) { return x(d[feature+'_'+selectedDimReduction+'_x']);})
										       .attr("cy", function(d) { return y(d[feature+'_'+selectedDimReduction+'_y']); })
							  			});
				svg.append('g')
				   .attr('class', 'brush')
				   .call(brush);

				// Add dots to scatterplots
				svg.append('g')
				   .selectAll('dot')
				   .data(data)
				   .enter()
				   .append('circle')
				   .attr('id', function(d) { return d.index.replaceAll("'",'-').replaceAll(' ', '_'); })
				   .attr('cx', function(d) { return x(d[feature+'_'+selectedDimReduction+'_x']); })
				   .attr('cy', function(d) { return y(d[feature+'_'+selectedDimReduction+'_y']); })
				   .attr('r', width/50)
				   .style('fill', 'lightblue')
				   .style('opacity', .8)
				   // Append dots to scatterplots
				   .on('mouseover', function(event,d) {
				   						d3.select(this).attr('r', parseFloat(d3.select(this).attr('r')) * 1.5);
				   						d3.select(this).attr('stroke', 'black');
										tooltip.transition()
											   .duration(200)
											   .style("opacity", .9);
										tooltip.style("left", (event.pageX) + "px")
											   .style("top", (event.pageY - 28) + "px")
											   .append('text').text(d.index).attr('alignment-baseline', 'middle');
									})
				   .on('mouseout', function(){
				   						d3.select(this).attr('r', parseFloat(d3.select(this).attr('r')) / 1.5);
				   						if (!d3.select(this).classed('clicked')) {
				   							d3.select(this).attr('stroke', null);
				   						}
				   						tooltip.transition()
				   							   .duration(50)
				   							   .style('opacity', 0);
				   						tooltip.selectAll('*').remove();
				   				   })
				   // Display indirect scatterplots on screen
				   .on('click', function(){
				   					var alreadyClicked = false;
				   					if (d3.select(this).classed('clicked')) {
				   						alreadyClicked = true;
				   						d3.select('#slider').selectAll('*').remove();
				   					}

				   					d3.selectAll('circle').classed('clicked', false);
				   					d3.selectAll('circle').attr('stroke', null);
				   					selectColorScale();

				   					if (!alreadyClicked) {
				   						d3.select(this).classed('clicked', true);
				   						d3.select(this).style('fill', 'red');
				   						d3.select(this).attr('stroke', 'black');

				   						var target = d3.select(this).attr('id');
				   						showDetails(target);
				   					}
				   				});

				// Function to add delay to zooming
				var idleTimeout
			  	function idled() { idleTimeout = null; }
			};

			function resetColorScale(){ // Reset color scaling on main scatterplot
				selectedColorScale = null; // Set selected color scale attribute to null

				// Reset dots to initial color, except clicked dot (set to red)
				d3.select('#divScatterPlot')
				  .selectAll('circle')
				  .style('fill', function(d){
				  					if ((d3.select('#'+d.index.replaceAll("'",'-').replaceAll(' ', '_')).classed) && 
				  						(d3.select('#'+d.index.replaceAll("'",'-').replaceAll(' ', '_')).attr('class') == 'clicked')){
				  						return 'red';
				  					} else {
				  						return 'lightblue';
				  					}
				  				})
				  .style('opacity', 0.8);
				d3.select('#legend').remove(); // Remove color scale legend
			};

			function selectColorScaleFeature(){ // Color scale feature selection
				resetColorScale(); // Reset color scaling on main scatterplot

				var colorScaleFeatureSelect = d3.select('#colorScaleFeature').node();
				var colorScaleSelect = d3.select('#colorScale');
				selectedColorScaleFeature = colorScaleFeatureSelect.options[colorScaleFeatureSelect.selectedIndex].value;

				colorScaleSelect.selectAll('option').remove(); // Reset color scate attributes menu

				// Add null color scale attribute option
				colorScaleSelect.append('option')
								.text('-')
							    .attr('value', ' ')
								.attr('id', 'nullColorScale');
				
				// Get color scale attributes options
				var data_corr = eval(selectedTarget + '_' + selectedColorScaleFeature + '_corr')[selectedModel];
				var colorScaleOptions = Array.from(d3.group(data_corr, d => d[selectedColorScaleFeature]).keys());
				if ((selectedColorScaleFeature != 'age') & (selectedColorScaleFeature != 'yob') & 
					(selectedColorScaleFeature != 'gender')){ colorScaleOptions = colorScaleOptions.sort(); }

				// Add other color scale attribute options
				colorScaleSelect.selectAll('featureAttr')
								.data(colorScaleOptions)
								.enter()
								.append('option')
								.text(function (d) { return d; })
								.attr('value', function (d) { return d; })
								.attr('id', function (d) { return d+'ColorScale'; });
				colorScaleSelect.on('change', selectColorScale);
			};

			function selectColorScale(){ // Color scale attibute selection
				resetColorScale(); // Reset color scaling on main scatterplot

				var colorScaleFeatureSelect = d3.select('#colorScaleFeature').node();
				var colorScaleAttributeSelect = d3.select('#colorScale').node();
				if (colorScaleAttributeSelect.selectedIndex != -1){
					selectedColorScale = colorScaleAttributeSelect.options[colorScaleAttributeSelect.selectedIndex].value;

					if (colorScaleFeatureSelect.selectedIndex != 0){
						var data_corr = eval(selectedTarget + '_' + selectedColorScaleFeature + '_corr')[selectedModel];
						if (colorScaleAttributeSelect.selectedIndex != 0){
							var data_corr_filtered = data_corr.filter(x => x[selectedColorScaleFeature] == selectedColorScale);

							// If color scale attribute selected, apply color scaling on all the dots
							d3.select('#divScatterPlot')
							  .selectAll('circle')
							  .style('fill', function(d){
							  					if ((d3.select('#'+d.index.replaceAll("'",'-').replaceAll(' ', '_')).classed) && 
							  						(d3.select('#'+d.index.replaceAll("'",'-').replaceAll(' ', '_')).attr('class') == 'clicked')){
							  						return 'red'; // Selected dot remains red
							  					} else {
							  						var corr_coef = parseFloat(data_corr_filtered.filter(x => 
							  														x[selectedTarget] == d.index
							  											  	  )[0].indirect_correlation).toFixed(4);
							  						return colorScale(corr_coef);
							  					}
							  				})
							  .style('opacity', .8);
							createLegend(); // Add legend to main scatterplot
						}
					}
				}
			};

			function createLegend(){ // Add legend to main scatterplot
				d3.select('#legend').remove();

				var scatterPlotDivDim = d3.select('#divScatterPlot').node().getBoundingClientRect();
				var scatterPlotDim = d3.select('#svg_'+selectedTarget+'_'+selectedFeature).node().getBoundingClientRect();

				var legend = Legend(colorScale, {title: 'Indirect correlation', tickValues: [colorScaleMin,0, colorScaleMax],
												 tickFormat: function(d) {return colorScaleLegend[d]},
												 marginLeft: (scatterPlotDim.x - scatterPlotDivDim.x), 
												 width: scatterPlotDim.width + (scatterPlotDim.x - scatterPlotDivDim.x)});
				legend.id = 'legend';
				d3.select('#divScatterPlot')
				  .node().appendChild(legend);
			};


			function showDetails(target){ // Display all the indirect scatterplots for the selected target
				var data_corr = eval(selectedTarget + '_' + selectedFeature + '_corr'
									)[selectedModel].filter(x => x[selectedTarget] == target.replaceAll('-',"'").replaceAll('_',' '));
				var data_indirect = eval(selectedTarget + '_' + selectedFeature + '_indirect')[selectedModel];
				var features = Array.from(d3.group(data_corr, d => d[selectedFeature]).keys());
				if ((selectedFeature != 'age') & (selectedFeature != 'yob') & 
					(selectedFeature != 'gender')){ features = features.sort(); }

				d3.select('#slider').selectAll('*').remove();

				var sliderDivList = ['#slider'];

				d3.select(sliderDivList[sliderDivList.length - 1])
				  .append('div')
				  .attr('id', 'slider-content')
				  .attr('class', 'slider-content');

				features.forEach(function(f){
					var divId = 'div_' + target + '_' + f;
					d3.select('#slider-content')
					  .append('div')
					  .attr('id', divId);
					sliderDivList = sliderDivList.concat(['#'+divId]);
				});

				features.forEach(function(f){
					var svgId = 'svg_' + target + '_' + f;
					createIndirectPlot(data_indirect, svgId, 
									   target.replaceAll('-',"'").replaceAll('_',' '), 
									   f.replaceAll('-',"'").replaceAll('_',' '));
				});
			};

			function createIndirectPlot(data, divId, x_name, y_name) { // Create indirect scatterplot
				// Define size and margins of the scatter plot
				var margin = {top: 40, right: 30, bottom: 30, left: 60},
					width = 400 - margin.left - margin.right,
					height = 350 - margin.top - margin.bottom;

				// Create SVG which will contain the scatterplot
				var svg = d3.select('#' + divId.replace('svg','div'))
							.append('svg')
							.attr('id', divId)
							.attr('preserveAspectRatio', 'xMinYMin meet')
							.attr('viewBox', '0 0 ' + (width + margin.left + margin.right) + ' ' + (height + margin.top + margin.bottom))
							.append('g')
							.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

				// Define axes
				var min_x = Math.round(d3.min(data, function(d){ return parseFloat(d[x_name]); }) * 2) / 2 - 0.5,
					max_x = Math.round(d3.max(data, function(d){ return parseFloat(d[x_name]); }) * 2) / 2 + 0.5,
					min_y = Math.round(d3.min(data, function(d){ return parseFloat(d[y_name]); }) * 2) / 2 - 0.5,
					max_y = Math.round(d3.max(data, function(d){ return parseFloat(d[y_name]); }) * 2) / 2 + 0.5;
				var x = d3.scaleLinear()
						  .domain([min_x,max_x])
						  .range([0, width]);
				var y = d3.scaleLinear()
						  .domain([min_y,max_y])
						  .range([height, 0]);

				// Append background to SVG
				svg.append('rect')
					.attr('width', width)
		   			.attr('height', height)
		   			.attr('fill', 'white')
		   			.attr('stroke', 'black')
		   			.attr('stroke-width', .4);

		   		// Append axes to SVG
				svg.append('g')
				   .style('font-size', '50%')
				   .attr('transform', 'translate(0,' + height + ')')
				   .call(d3.axisBottom(x));
				svg.append('g')
				   .style('font-size', '50%')
				   .call(d3.axisLeft(y));
				svg.append("text")
				   .attr("text-anchor", "end")
				   .attr('font-size', '70%')
				   .attr("x", width/2 + margin.left/3)
				   .attr("y", height + margin.top)
				   .text(x_name);
				svg.append("text")
				   .attr("text-anchor", "end")
				   .attr('font-size', '70%')
				   .attr("transform", "rotate(-90)")
				   .attr("y", -margin.left + 30)
				   .attr("x", -margin.top - height/3 + 5)
				   .text(y_name);


				// Append legend tooltip for dots
				var tooltip = d3.select('#' + divId.replace('svg','div'))
								.append('div')
								.attr('class', 'tooltip')
								.style('opacity', 0);

				// Append dots to scatterplots
				svg.append('g')
				   .selectAll('dot')
				   .data(data)
				   .enter()
				   .append('circle')
				   .attr('id', function(d) { return d.index; })
				   .attr('cx', function(d) { return x(d[x_name]); })
				   .attr('cy', function(d) { return y(d[y_name]); })
				   .attr('r', 2)
				   .style("fill", 'lightblue')
				   .style('opacity', .5)
				   // Display legend tooltip when mouse over the dot
				   .on('mouseover', function(event,d) {
				   						d3.select(this).style('fill', 'red').style('opacity', .8);
										tooltip.transition()
											   .duration(200)
											   .style("opacity", .9);

										let rect = d3.select(this).node().parentElement.parentElement.getBoundingClientRect();

										tooltip.html(d.index + 
													 '<br/> ' + x_name + ': ' + (Math.round((parseFloat(d[x_name]) + Number.EPSILON) * 1e4) / 1e4) + 
													 '<br/> ' + y_name + ': ' + (Math.round((parseFloat(d[y_name]) + Number.EPSILON) * 1e4) / 1e4) )
											   .style('left', (event.x - rect.left + 10) + 'px')
											   .style('bottom', (rect.bottom - event.y) + 'px');
									})
				   .on('mouseout', function(){
				   						if( !d3.select(this).classed('clicked')){
					   						d3.select(this).style('fill', 'lightblue');
				   						}
				   						tooltip.transition()
				   							   .duration(500)
				   							   .style('opacity', 0);
				   				   });

				// Append least squares regression line
				var xSeries = data.map(function(d){ return parseFloat(d[x_name]); });
				var ySeries = data.map(function(d){ return parseFloat(d[y_name]); });
				var leastSquaresCoeff = leastSquares(xSeries, ySeries);
				var trendData = [leastSquaresLimit(leastSquaresCoeff, [min_x, max_x, min_y, max_y])]
				var trendline = svg.selectAll(".trendline")
								   .data(trendData);
				trendline.enter()
						 .append("line")
						 .attr("class", "trendline")
						 .attr("x1", function(d) { return x(d[0]); })
						 .attr("y1", function(d) { return y(d[1]); })
						 .attr("x2", function(d) { return x(d[2]); })
						 .attr("y2", function(d) { return y(d[3]); })
						 .attr("stroke", "black")
						 .attr("stroke-width", 1);
			};

			function leastSquares(xSeries, ySeries) { // Compute least squares regression between 2 arrays
				var reduceSumFunc = function(prev, cur) { return prev + cur; };

				var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
				var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

				var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
					.reduce(reduceSumFunc);

				var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
					.reduce(reduceSumFunc);
					
				var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
					.reduce(reduceSumFunc);
					
				var slope = ssXY / ssXX;
				var intercept = yBar - (xBar * slope);
				var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

				return [slope, intercept, rSquare];
			};

			function leastSquaresLimit(leastSquaresCoeff, plotLimits){ // Get coordinates of the limits for least squares regression line
				var y1 = leastSquaresCoeff[0] * plotLimits[0] + leastSquaresCoeff[1],
					y2 = leastSquaresCoeff[0] * plotLimits[1] + leastSquaresCoeff[1];

				if (y1 < plotLimits[2]){
					var y_min_lim = plotLimits[2],
						x_min_lim = (y_min_lim - leastSquaresCoeff[1]) / leastSquaresCoeff[0];
				} else if (y1 > plotLimits[3]){
					var y_min_lim = plotLimits[3],
						x_min_lim = (y_min_lim - leastSquaresCoeff[1]) / leastSquaresCoeff[0];
				} else {
					var y_min_lim = y1,
						x_min_lim = plotLimits[0];
				}
				if (y2 > plotLimits[3]){
					var y_max_lim = plotLimits[3],
						x_max_lim = (y_max_lim - leastSquaresCoeff[1]) / leastSquaresCoeff[0];
				} else if (y2 < plotLimits[2]){
					var y_max_lim = plotLimits[2],
						x_max_lim = (y_max_lim - leastSquaresCoeff[1]) / leastSquaresCoeff[0];
				} else {
					var y_max_lim = y2,
						x_max_lim = plotLimits[1];
				}

				return [x_min_lim, y_min_lim, x_max_lim, y_max_lim];
			};


			function displayVisulization(){ // Hide introduction and display visualization
				d3.select('#introductionDiv').attr('hidden', true);
				d3.select('#visualizationDiv').attr('hidden', null);
			};

			function showExplanations(){ // Display or hide explanations
				if (!explanationsShown){
					d3.select('#explanationsNull').attr('hidden', true);
					d3.select('#explanations').attr('hidden', null);
					d3.select('#explanationsButton').text('Hide introduction text');
					explanationsShown = true;
				} else {
					d3.select('#explanationsNull').attr('hidden', null);
					d3.select('#explanations').attr('hidden', true);
					d3.select('#explanationsButton').text('Show introduction text');
					explanationsShown = false;
				}
			};
			

			// Load data
			loadFilesInit();
			loadFiles();
			setTimeout(function(){
				setUpVisualization(); // Initialize visualization
			}, delay);
		</script>
	</body>
</html>